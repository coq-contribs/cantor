<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Ordinals.rpo.term</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Ordinals.rpo.term</h1>

<code>
</code>

<div class="doc">
<a name="lab38"></a><h1>Term algebra defined as functor from a Module Signature and a Module Variable.</h1 class="section">

</div>
<code>

<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> List.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="Ordinals.prelude.more_list.html">more_list</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="Ordinals.prelude.list_permut.html">list_permut</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="Ordinals.prelude.list_set.html">list_set</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Arith.<br/>

<br/>

<br/>
</code>

<div class="doc">
<a name="lab39"></a><h1>Module Type Signature.</h1 class="section">

 There are almost no assumptions, except a decidable equality 
and an arity function. 
</div>
<code>
<span class="keyword">Module</span> Type <a name="Signature"></a>Signature.<br/>

<br/>
<span class="keyword">Parameter</span> <a name="symb"></a>symb : Set.<br/>
<span class="keyword">Axiom</span> <a name="eq_symbol_dec"></a>eq_symbol_dec : forall f1 f2 : symb, {f1 = f2} + {f1 &lt;&gt; f2}.<br/>

<br/>
</code>

<div class="doc">
The arity of a symbol contains also the information about built-in theories as in CiME 
</div>
<code>
<span class="keyword">Inductive</span> <a name="arity_type"></a>arity_type : Set :=<br/>
&nbsp;&nbsp;| <a name="AC"></a>AC : arity_type<br/>
&nbsp;&nbsp;| <a name="C"></a>C : arity_type<br/>
&nbsp;&nbsp;| <a name="Free"></a>Free : nat -&gt; arity_type.<br/>

<br/>
<span class="keyword">Parameter</span> <a name="arity"></a>arity : symb -&gt; arity_type.<br/>
<span class="keyword">End</span> Signature.<br/>

<br/>
</code>

<div class="doc">
<a name="lab40"></a><h1>Module Type Variables.</h1 class="section">

 There are almost no assumptions, except a decidable equality. 
</div>
<code>
<span class="keyword">Module</span> Type <span class="keyword">Variables</span>.<br/>

<br/>
<span class="keyword">Parameter</span> <a name="var"></a>var : Set.<br/>
<span class="keyword">Axiom</span> <a name="eq_variable_dec"></a>eq_variable_dec : forall v1 v2 : var, {v1 = v2} + {v1 &lt;&gt; v2}.<br/>

<br/>
<span class="keyword">End</span> <span class="keyword">Variables</span>.<br/>

<br/>
</code>

<div class="doc">
<a name="lab41"></a><h1>Module Type Term built from a signature and a set of variables.</h1 class="section">

</div>
<code>
<span class="keyword">Module</span> Type <a name="Term"></a>Term.<br/>

<br/>
Declare <span class="keyword">Module</span> <a name="F"></a>F : Signature.<br/>
Declare <span class="keyword">Module</span> <a name="X"></a>X : <span class="keyword">Variables</span>.<br/>

<br/>
<span class="keyword">Definition</span> <a name="symbol"></a>symbol := F.symb.<br/>
<span class="keyword">Definition</span> <a name="variable"></a>variable := X.var.<br/>

<br/>
<span class="keyword">Import</span> F.<br/>
<span class="keyword">Import</span> X.<br/>

<br/>
<span class="keyword">Ltac</span> destruct_arity f n Af :=<br/>
generalize (refl_equal (arity f)); pattern f at 1; destruct (arity f) as [ |  | n]; intro Af.<br/>

<br/>
</code>

<div class="doc">
Definition of terms. 
Arity is not taken into account, and terms may be hill-formed. 
</div>
<code>
<span class="keyword">Inductive</span> <a name="term"></a>term : Set :=<br/>
&nbsp;&nbsp;| <a name="Var"></a>Var : variable -&gt; term<br/>
&nbsp;&nbsp;| <a name="Term"></a>Term : symbol -&gt; list term -&gt; term.<br/>

<br/>
<span class="keyword">Definition</span> <a name="direct_subterm"></a>direct_subterm t1 t2 : Prop :=<br/>
&nbsp;&nbsp;match t2 with<br/>
&nbsp;&nbsp;| Var _ =&gt; False<br/>
&nbsp;&nbsp;| Term _ l =&gt; In t1 l<br/>
&nbsp;&nbsp;end.<br/>

<br/>
</code>

<div class="doc">
Definition and a few properties of the size of a term.
</div>
<code>
<span class="keyword">Fixpoint</span> <a name="size"></a>size (t:term) : nat :=<br/>
&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;| Var v =&gt; 1<br/>
&nbsp;&nbsp;| Term f l =&gt; 1 + fold_left (fun size_acc e =&gt; size_acc + size e) l 0<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="size_unfold"></a>size_unfold :<br/>
&nbsp;forall t, size t = match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Term f l =&gt; 1 + list_size size l<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="size_ge_one"></a>size_ge_one : forall t, 1 &lt;= size t.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="size_direct_subterm"></a>size_direct_subterm :<br/>
&nbsp;forall t1 t2, direct_subterm t1 t2 -&gt; size t1 &lt; size t2.<br/>

<br/>
</code>

<div class="doc">
<a name="lab42"></a><h2>Recursion on terms.</h2 class="section">

</div>
<code>
<span class="keyword">Section</span> Recursion.<br/>
<span class="keyword">Variable</span> P : term -&gt; Type.<br/>
<span class="keyword">Variable</span> Pl : list term -&gt; Type.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="term_rec2"></a>term_rec2 : (forall n t, size t &lt;= n -&gt; P t) -&gt; forall t, P t.<br/>
<span class="keyword">Axiom</span> <a name="term_rec3"></a>term_rec3 :<br/>
&nbsp;&nbsp;(forall v, P (Var v)) -&gt; (forall f l, (forall t, In t l -&gt; P t) -&gt; P (Term f l)) -&gt; forall t, P t.<br/>
<span class="keyword">Axiom</span> <a name="term_rec4"></a>term_rec4 :<br/>
&nbsp;&nbsp;(forall v, P (Var v)) -&gt; (forall f l, Pl l -&gt; P (Term f l)) -&gt;<br/>
&nbsp;&nbsp;(forall l, (forall t, In t l -&gt; P t) -&gt; Pl l) -&gt; forall t, P t.<br/>
<span class="keyword">End</span> Recursion.<br/>

<br/>
</code>

<div class="doc">
<a name="lab43"></a><h2>Double recursion on terms.</h2 class="section">

</div>
<code>
<span class="keyword">Section</span> DoubleRecursion.<br/>
<span class="keyword">Variable</span> P2 : term -&gt; term -&gt; Type.<br/>
<span class="keyword">Variable</span> Pl2 : list term -&gt; list term -&gt; Type.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="term_rec7"></a>term_rec7 :<br/>
&nbsp;&nbsp;(forall v1 t2, P2 (Var v1) t2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall t1 v2, P2 t1 (Var v2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall f1 f2 l1 l2, Pl2 l1 l2 -&gt; P2 (Term f1 l1) (Term f2 l2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall l1 l2, (forall t1 t2, In t1 l1 -&gt; In t2 l2 -&gt; P2 t1 t2) -&gt; Pl2 l1 l2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall t1 t2, P2 t1 t2.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="term_rec8"></a>term_rec8 :<br/>
&nbsp;&nbsp;(forall v1 t2, P2 (Var v1) t2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall t1 v2, P2 t1 (Var v2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall f1 f2 l1 l2, Pl2 l1 l2 -&gt; P2 (Term f1 l1) (Term f2 l2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall l1 l2, (forall t1 t2, In t1 l1 -&gt; In t2 l2 -&gt; P2 t1 t2) -&gt; Pl2 l1 l2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall l1 l2, Pl2 l1 l2.<br/>
<span class="keyword">End</span> DoubleRecursion.<br/>

<br/>
</code>

<div class="doc">
<a name="lab44"></a><h2>Equality on terms is decidable.</h2 class="section">

</div>
<code>
<span class="keyword">Axiom</span> <a name="eq_term_dec"></a>eq_term_dec :  forall t1 t2:term, {t1 = t2} + {t1 &lt;&gt; t2}.<br/>
Declare <span class="keyword">Module</span> <a name="Term_eq_dec"></a>Term_eq_dec : decidable_set.S with <span class="keyword">Definition</span> <a name="A"></a>A:= term <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with <span class="keyword">Definition</span> <a name="eq_A_dec"></a>eq_A_dec := eq_term_dec.<br/>

<br/>
</code>

<div class="doc">
<a name="lab45"></a><h2>Well-formedness of terms, according to the arity.</h2 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="well_formed"></a>well_formed (t:term) : Prop :=<br/>
&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;| Var _ =&gt; True<br/>
&nbsp;&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let well_formed_list :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fix well_formed_list (l:list term) : Prop :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; True<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| h :: tl =&gt; well_formed h /\ well_formed_list tl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end) in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;well_formed_list l /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(match arity f with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Free n =&gt; length l = n <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; length l = 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="well_formed_unfold"></a>well_formed_unfold :<br/>
&nbsp;forall t, well_formed t -&gt;<br/>
&nbsp;match t with <br/>
&nbsp;| Var _ =&gt; True<br/>
&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall u, In u l -&gt; well_formed u) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(match arity f with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Free n =&gt; length l = n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; length l = 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="well_formed_fold"></a>well_formed_fold :<br/>
&nbsp;forall t,<br/>
&nbsp;match t with <br/>
&nbsp;| Var _ =&gt; True<br/>
&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall u, In u l -&gt; well_formed u) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(match arity f with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Free n =&gt; length l = n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; length l = 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;end -&gt; well_formed t.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="well_formed_list"></a>well_formed_list (l : list term) : Prop :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; True<br/>
&nbsp;&nbsp;| h :: tl =&gt; well_formed h /\ well_formed_list tl<br/>
&nbsp;&nbsp;end.<br/>

<br/>
</code>

<div class="doc">
<a name="lab46"></a><h2>Substitutions.</h2 class="section">

</div>
<code>
<span class="keyword">Definition</span> <a name="substitution"></a>substitution := list (variable * term).<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="apply_subst"></a>apply_subst (sigma : substitution) (t : term) {struct t} : term :=<br/>
&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;| Var v =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;match find eq_variable_dec v sigma with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Some v_sigma =&gt; v_sigma<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;| Term f l =&gt; Term f (map (apply_subst sigma) l)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="empty_subst_is_id"></a>empty_subst_is_id : forall t, apply_subst nil t = t.<br/>
<span class="keyword">Axiom</span> <a name="empty_subst_is_id_list"></a>empty_subst_is_id_list : forall l, map (apply_subst nil) l = l.<br/>

<br/>
</code>

<div class="doc">
Composition of substitutions. 
</div>
<code>
<span class="keyword">Definition</span> <a name="map_subst"></a>map_subst (f : variable -&gt; term -&gt; term) sigma :=<br/>
&nbsp;&nbsp;map (fun x =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match (x : variable * term) with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (v, v_sigma) =&gt; (v, f v v_sigma)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigma.<br/>

<br/>
<span class="keyword">Definition</span> <a name="subst_comp"></a>subst_comp sigma1 sigma2 :=<br/>
&nbsp;&nbsp;(map_subst (fun _ t =&gt; apply_subst sigma1 t) sigma2)<br/>
&nbsp;&nbsp;++ <br/>
&nbsp;&nbsp;(map_subst (fun v t =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match find eq_variable_dec v sigma2 with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some v_sigma2 =&gt; apply_subst sigma1 v_sigma2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigma1).<br/>

<br/>
<span class="keyword">Axiom</span> <a name="subst_comp_is_subst_comp_aux1"></a>subst_comp_is_subst_comp_aux1 :<br/>
&nbsp;&nbsp;forall v sigma f,<br/>
&nbsp;&nbsp;find eq_variable_dec v (map_subst f sigma) =<br/>
&nbsp;&nbsp;&nbsp;match find eq_variable_dec v sigma with<br/>
&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;| Some t =&gt; Some (f v t)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="subst_comp_is_subst_comp"></a>subst_comp_is_subst_comp :<br/>
&nbsp;&nbsp;forall sigma1 sigma2 t,<br/>
&nbsp;&nbsp;&nbsp;apply_subst (subst_comp sigma1 sigma2) t =<br/>
&nbsp;&nbsp;&nbsp;apply_subst sigma1 (apply_subst sigma2 t).<br/>

<br/>
</code>

<div class="doc">
Well-formed substitutions. 
</div>
<code>
<span class="keyword">Definition</span> <a name="well_formed_subst"></a>well_formed_subst sigma :=<br/>
&nbsp;&nbsp;forall v, match find eq_variable_dec v sigma with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; True<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t =&gt; well_formed t <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="well_formed_apply_subst"></a>well_formed_apply_subst :<br/>
&nbsp;&nbsp;forall sigma, well_formed_subst sigma -&gt; <br/>
&nbsp;&nbsp;forall t, well_formed t -&gt; well_formed (apply_subst sigma t).<br/>

<br/>
</code>

<div class="doc">
<a name="lab47"></a><h2>Positions in a term.</h2 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="is_a_pos"></a>is_a_pos (t : term) (p : list nat) {struct p}: bool :=<br/>
&nbsp;&nbsp;match p with<br/>
&nbsp;&nbsp;| nil =&gt; true<br/>
&nbsp;&nbsp;| i :: q =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Term _ l =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match nth_error l i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some ti =&gt; is_a_pos ti q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subterm_at_pos"></a>subterm_at_pos (t : term) (p : list nat) {struct p}: option term :=<br/>
&nbsp;&nbsp;match p with<br/>
&nbsp;&nbsp;| nil =&gt; Some t<br/>
&nbsp;&nbsp;| i :: q =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Term _ l =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match nth_error l i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some ti =&gt; subterm_at_pos ti q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="size_subterm_at_pos"></a>size_subterm_at_pos :<br/>
&nbsp;&nbsp;forall t i p, match subterm_at_pos t (i :: p) with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some u =&gt; size u &lt; size t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; True<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="is_a_pos_exists_subtem"></a>is_a_pos_exists_subtem :<br/>
&nbsp;&nbsp;forall t p, is_a_pos t p = true -&gt; exists u, subterm_at_pos t p = Some u.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="replace_at_pos"></a>replace_at_pos (t u : term) (p : list nat) {struct p} : term :=<br/>
&nbsp;&nbsp;match p with<br/>
&nbsp;&nbsp;| nil =&gt; u<br/>
&nbsp;&nbsp;| i :: q =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let replace_at_pos_list :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fix replace_at_pos_list j (l : list term) {struct l}: list term :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| h :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match j with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| O =&gt; (replace_at_pos h u q) :: tl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| S k =&gt; h :: (replace_at_pos_list k tl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end) in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Term f (replace_at_pos_list i l)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="replace_at_pos_list"></a>replace_at_pos_list (l : list term) (u : term) (i : nat) (p : list nat) <br/>
&nbsp;{struct l}: list term :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; nil<br/>
&nbsp;&nbsp;| h :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| O =&gt; (replace_at_pos h u p) :: tl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| S j =&gt; h :: (replace_at_pos_list tl  u j p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="replace_at_pos_unfold"></a>replace_at_pos_unfold :<br/>
&nbsp;&nbsp;forall f l u i q,<br/>
&nbsp;&nbsp;&nbsp;replace_at_pos (Term f l) u (i :: q) = Term f (replace_at_pos_list l u i q).<br/>

<br/>
<span class="keyword">Axiom</span> <a name="replace_at_pos_is_replace_at_pos1"></a>replace_at_pos_is_replace_at_pos1 :<br/>
&nbsp;&nbsp;forall t u p, is_a_pos t p = true -&gt;<br/>
&nbsp;&nbsp;subterm_at_pos (replace_at_pos t u p) p = Some u.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="replace_at_pos_is_replace_at_pos2"></a>replace_at_pos_is_replace_at_pos2 :<br/>
&nbsp;&nbsp;forall t p u, subterm_at_pos t p = Some u -&gt; replace_at_pos t u p = t.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="subterm_at_pos_apply_subst_apply_subst_subterm_at_pos"></a>subterm_at_pos_apply_subst_apply_subst_subterm_at_pos :<br/>
&nbsp;&nbsp;forall t p sigma, <br/>
&nbsp;&nbsp;match subterm_at_pos t p with<br/>
&nbsp;&nbsp;| Some u =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subterm_at_pos (apply_subst sigma t) p = Some (apply_subst sigma u)<br/>
&nbsp;&nbsp;| None =&gt; True<br/>
end.<br/>

<br/>
<span class="keyword">Axiom</span> <a name="replace_at_pos_list_replace_at_pos_in_subterm"></a>replace_at_pos_list_replace_at_pos_in_subterm :<br/>
forall l1 ui l2 u i p, length l1 = i -&gt;<br/>
&nbsp;replace_at_pos_list (l1 ++ ui :: l2) u i p = <br/>
&nbsp;l1 ++ (replace_at_pos ui u p) :: l2.<br/>

<br/>
<span class="keyword">End</span> Term.<br/>

<br/>
</code>

<div class="doc">
<a name="lab48"></a><h1>A functor building a Term Module from a Signature and a set of Variables.</h1 class="section">

</div>
<code>

<br/>
<span class="keyword">Module</span> <a name="Make"></a>Make (F1 : Signature) (X1 : <span class="keyword">Variables</span>) &lt;: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Term with <span class="keyword">Module</span> <a name="F"></a>F := F1 with <span class="keyword">Module</span> <a name="X"></a>X := X1.<br/>

<br/>
<span class="keyword">Module</span> <a name="F"></a>F := F1.<br/>
<span class="keyword">Module</span> <a name="X"></a>X := X1.<br/>

<br/>
<span class="keyword">Definition</span> <a name="symbol"></a>symbol := F.symb.<br/>
<span class="keyword">Definition</span> <a name="variable"></a>variable := X.var.<br/>

<br/>
<span class="keyword">Import</span> F.<br/>
<span class="keyword">Import</span> X.<br/>

<br/>
<span class="keyword">Module</span> <a name="DecVar"></a>DecVar &lt;: decidable_set.S.<br/>
<span class="keyword">Definition</span> <a name="A"></a>A := variable.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="eq_A_dec"></a>eq_A_dec : forall x y : A, { x = y } + { x &lt;&gt; y }.<br/>

<br/>
<span class="keyword">End</span> DecVar.<br/>

<br/>
<span class="keyword">Module</span> <a name="VSet"></a>VSet &lt;: list_set.S with <span class="keyword">Definition</span> <a name="DS"></a>DS.A := variable :=<br/>
list_set.Make (DecVar).<br/>

<br/>
</code>

<div class="doc">
Definition of terms. 
Arity is not taken into account, and terms may be ill-formed. 
</div>
<code>
<span class="keyword">Inductive</span> <a name="term"></a>term : Set :=<br/>
&nbsp;&nbsp;| <a name="Var"></a>Var : variable -&gt; term<br/>
&nbsp;&nbsp;| <a name="Term"></a>Term : symbol -&gt; list term -&gt; term.<br/>

<br/>
<span class="keyword">Definition</span> <a name="direct_subterm"></a>direct_subterm t1 t2 : Prop :=<br/>
&nbsp;&nbsp;match t2 with<br/>
&nbsp;&nbsp;| Var _ =&gt; False<br/>
&nbsp;&nbsp;| Term _ l =&gt; In t1 l<br/>
&nbsp;&nbsp;end.<br/>

<br/>
</code>

<div class="doc">
Definition and a few properties of the size of a term.
</div>
<code>
<span class="keyword">Fixpoint</span> <a name="size"></a>size (t:term) : nat :=<br/>
&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;| Var v =&gt; 1<br/>
&nbsp;&nbsp;| Term f l =&gt; 1 + fold_left (fun size_acc e =&gt; size_acc + size e) l 0<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="size_unfold"></a>size_unfold :<br/>
&nbsp;forall t,<br/>
&nbsp;size t = match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Term f l =&gt; 1 + list_size size l<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="size_ge_one"></a>size_ge_one : forall t, 1 &lt;= size t.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="size_direct_subterm"></a>size_direct_subterm :<br/>
&nbsp;forall t1 t2, direct_subterm t1 t2 -&gt; size t1 &lt; size t2.<br/>

<br/>
</code>

<div class="doc">
<a name="lab49"></a><h2>Recursion on terms.</h2 class="section">

</div>
<code>
<span class="keyword">Section</span> Recursion.<br/>
<span class="keyword">Variable</span> P : term -&gt; Type.<br/>
<span class="keyword">Variable</span> Pl : list term -&gt; Type.<br/>

<br/>
<span class="keyword">Definition</span> <a name="term_rec2"></a>term_rec2 : (forall n t, size t &lt;= n -&gt; P t) -&gt; forall t, P t.<br/>

<br/>
<span class="keyword">Definition</span> <a name="term_rec3"></a>term_rec3 :<br/>
&nbsp;&nbsp;(forall v, P (Var v)) -&gt; (forall f l, (forall t, In t l -&gt; P t) -&gt; P (Term f l)) -&gt; forall t, P t.<br/>

<br/>
<span class="keyword">Definition</span> <a name="term_rec4"></a>term_rec4 :<br/>
&nbsp;&nbsp;(forall v, P (Var v)) -&gt; (forall f l, Pl l -&gt; P (Term f l)) -&gt;<br/>
&nbsp;&nbsp;(forall l, (forall t, In t l -&gt; P t) -&gt; Pl l) -&gt; forall t, P t.<br/>
<span class="keyword">End</span> Recursion.<br/>

<br/>
</code>

<div class="doc">
<a name="lab50"></a><h2>Double recursion on terms.</h2 class="section">

</div>
<code>
<span class="keyword">Section</span> DoubleRecursion.<br/>
<span class="keyword">Variable</span> P2 : term -&gt; term -&gt; Type.<br/>
<span class="keyword">Variable</span> Pl2 : list term -&gt; list term -&gt; Type.<br/>

<br/>
<span class="keyword">Definition</span> <a name="term_rec7"></a>term_rec7 :<br/>
&nbsp;&nbsp;(forall v1 t2, P2 (Var v1) t2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall t1 v2, P2 t1 (Var v2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall f1 f2 l1 l2, Pl2 l1 l2 -&gt; P2 (Term f1 l1) (Term f2 l2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall l1 l2, (forall t1 t2, In t1 l1 -&gt; In t2 l2 -&gt; P2 t1 t2) -&gt; Pl2 l1 l2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall t1 t2, P2 t1 t2.<br/>

<br/>
<span class="keyword">Definition</span> <a name="term_rec8"></a>term_rec8 :<br/>
&nbsp;&nbsp;(forall v1 t2, P2 (Var v1) t2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall t1 v2, P2 t1 (Var v2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall f1 f2 l1 l2, Pl2 l1 l2 -&gt; P2 (Term f1 l1) (Term f2 l2)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(forall l1 l2, (forall t1 t2, In t1 l1 -&gt; In t2 l2 -&gt; P2 t1 t2) -&gt; Pl2 l1 l2) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forall l1 l2, Pl2 l1 l2.<br/>
<span class="keyword">End</span> DoubleRecursion.<br/>

<br/>
</code>

<div class="doc">
<a name="lab51"></a><h2>Equality on terms is decidable.</h2 class="section">

</div>
<code>
<span class="keyword">Theorem</span> <a name="eq_term_dec"></a>eq_term_dec : <br/>
&nbsp;&nbsp;forall t1 t2:term, {t1 = t2} + {t1 &lt;&gt; t2}.<br/>

<br/>

<br/>

<br/>
<span class="keyword">Module</span> <a name="Term_eq_dec"></a>Term_eq_dec : decidable_set.S with <span class="keyword">Definition</span> <a name="A"></a>A:= term <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with <span class="keyword">Definition</span> <a name="eq_A_dec"></a>eq_A_dec := eq_term_dec.<br/>
<span class="keyword">Definition</span> <a name="A"></a>A := term.<br/>
<span class="keyword">Definition</span> <a name="eq_A_dec"></a>eq_A_dec := eq_term_dec.<br/>
<span class="keyword">End</span> Term_eq_dec.<br/>

<br/>
</code>

<div class="doc">
<a name="lab52"></a><h2>Well-formedness of terms, according to the arity.</h2 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="well_formed"></a>well_formed (t:term) : Prop :=<br/>
&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;| Var _ =&gt; True<br/>
&nbsp;&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let well_formed_list :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fix well_formed_list (l:list term) : Prop :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; True<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| h :: tl =&gt; well_formed h /\ well_formed_list tl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end) in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;well_formed_list l /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(match arity f with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Free n =&gt; length l = n <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; length l = 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="well_formed_unfold"></a>well_formed_unfold :<br/>
&nbsp;forall t, well_formed t -&gt;<br/>
&nbsp;match t with <br/>
&nbsp;| Var _ =&gt; True<br/>
&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall u, In u l -&gt; well_formed u) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(match arity f with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Free n =&gt; length l = n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; length l = 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="well_formed_fold"></a>well_formed_fold :<br/>
&nbsp;forall t,<br/>
&nbsp;match t with <br/>
&nbsp;| Var _ =&gt; True<br/>
&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall u, In u l -&gt; well_formed u) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(match arity f with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Free n =&gt; length l = n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| _ =&gt; length l = 2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;end -&gt; well_formed t.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="well_formed_list"></a>well_formed_list (l : list term) : Prop :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; True<br/>
&nbsp;&nbsp;| h :: tl =&gt; well_formed h /\ well_formed_list tl<br/>
&nbsp;&nbsp;end.<br/>

<br/>
</code>

<div class="doc">
<a name="lab53"></a><h2>Substitutions.</h2 class="section">

</div>
<code>
<span class="keyword">Definition</span> <a name="substitution"></a>substitution := list (variable * term).<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="apply_subst"></a>apply_subst (sigma : substitution) (t : term) {struct t} : term :=<br/>
&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;| Var v =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;match find eq_variable_dec v sigma with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Some v_sigma =&gt; v_sigma<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;| Term f l =&gt; Term f (map (apply_subst sigma) l)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="empty_subst_is_id"></a>empty_subst_is_id : forall t, apply_subst nil t = t.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="empty_subst_is_id_list"></a>empty_subst_is_id_list : forall l, map (apply_subst nil) l = l.<br/>

<br/>
</code>

<div class="doc">
Composition of substitutions. 
</div>
<code>
<span class="keyword">Definition</span> <a name="map_subst"></a>map_subst (f : variable -&gt; term -&gt; term) sigma :=<br/>
&nbsp;&nbsp;map (fun x =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match (x : variable * term) with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (v, v_sigma) =&gt; (v, f v v_sigma)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigma.<br/>

<br/>
<span class="keyword">Definition</span> <a name="subst_comp"></a>subst_comp sigma1 sigma2 :=<br/>
&nbsp;&nbsp;(map_subst (fun _ t =&gt; apply_subst sigma1 t) sigma2)<br/>
&nbsp;&nbsp;++ <br/>
&nbsp;&nbsp;(map_subst (fun v t =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match find eq_variable_dec v sigma2 with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some v_sigma2 =&gt; apply_subst sigma1 v_sigma2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigma1).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_comp_is_subst_comp_aux1"></a>subst_comp_is_subst_comp_aux1 :<br/>
&nbsp;&nbsp;forall v sigma f,<br/>
&nbsp;&nbsp;find eq_variable_dec v (map_subst f sigma) =<br/>
&nbsp;&nbsp;&nbsp;match find eq_variable_dec v sigma with<br/>
&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;| Some t =&gt; Some (f v t)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subst_comp_is_subst_comp_aux2"></a>subst_comp_is_subst_comp_aux2 :<br/>
&nbsp;&nbsp;forall v sigma1 sigma2,<br/>
&nbsp;&nbsp;find (B:= term) eq_variable_dec v (sigma1 ++ sigma2)  =<br/>
&nbsp;&nbsp;match find eq_variable_dec v sigma1 with<br/>
&nbsp;&nbsp;| Some _ =&gt; find eq_variable_dec v sigma1<br/>
&nbsp;&nbsp;| None =&gt; find eq_variable_dec v sigma2<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Theorem</span> <a name="subst_comp_is_subst_comp"></a>subst_comp_is_subst_comp :<br/>
&nbsp;&nbsp;forall sigma1 sigma2 t,<br/>
&nbsp;&nbsp;&nbsp;apply_subst (subst_comp sigma1 sigma2) t =<br/>
&nbsp;&nbsp;&nbsp;apply_subst sigma1 (apply_subst sigma2 t).<br/>

<br/>
</code>

<div class="doc">
Well-formed substitutions. 
</div>
<code>
<span class="keyword">Definition</span> <a name="well_formed_subst"></a>well_formed_subst sigma :=<br/>
&nbsp;&nbsp;forall v, match find eq_variable_dec v sigma with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; True<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some t =&gt; well_formed t <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Theorem</span> <a name="well_formed_apply_subst"></a>well_formed_apply_subst :<br/>
&nbsp;&nbsp;forall sigma, well_formed_subst sigma -&gt; <br/>
&nbsp;&nbsp;forall t, well_formed t -&gt; well_formed (apply_subst sigma t).<br/>

<br/>
</code>

<div class="doc">
<a name="lab54"></a><h2>Positions in a term.</h2 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="is_a_pos"></a>is_a_pos (t : term) (p : list nat) {struct p}: bool :=<br/>
&nbsp;&nbsp;match p with<br/>
&nbsp;&nbsp;| nil =&gt; true<br/>
&nbsp;&nbsp;| i :: q =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Term _ l =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match nth_error l i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some ti =&gt; is_a_pos ti q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; false<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="subterm_at_pos"></a>subterm_at_pos (t : term) (p : list nat) {struct p}: option term :=<br/>
&nbsp;&nbsp;match p with<br/>
&nbsp;&nbsp;| nil =&gt; Some t<br/>
&nbsp;&nbsp;| i :: q =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| Term _ l =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match nth_error l i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some ti =&gt; subterm_at_pos ti q<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="size_subterm_at_pos"></a>size_subterm_at_pos :<br/>
&nbsp;&nbsp;forall t i p, match subterm_at_pos t (i :: p) with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some u =&gt; size u &lt; size t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; True<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="is_a_pos_exists_subtem"></a>is_a_pos_exists_subtem :<br/>
&nbsp;&nbsp;forall t p, is_a_pos t p = true -&gt; exists u, subterm_at_pos t p = Some u.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="replace_at_pos"></a>replace_at_pos (t u : term) (p : list nat) {struct p} : term :=<br/>
&nbsp;&nbsp;match p with<br/>
&nbsp;&nbsp;| nil =&gt; u<br/>
&nbsp;&nbsp;| i :: q =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match t with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Var _ =&gt; t<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Term f l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let replace_at_pos_list :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fix replace_at_pos_list j (l : list term) {struct l}: list term :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| h :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match j with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| O =&gt; (replace_at_pos h u q) :: tl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| S k =&gt; h :: (replace_at_pos_list k tl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end) in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Term f (replace_at_pos_list i l)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="replace_at_pos_list"></a>replace_at_pos_list (l : list term) (u : term) (i : nat) (p : list nat) <br/>
&nbsp;{struct l}: list term :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; nil<br/>
&nbsp;&nbsp;| h :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| O =&gt; (replace_at_pos h u p) :: tl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| S j =&gt; h :: (replace_at_pos_list tl  u j p)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="replace_at_pos_unfold"></a>replace_at_pos_unfold :<br/>
&nbsp;&nbsp;forall f l u i q,<br/>
&nbsp;&nbsp;&nbsp;replace_at_pos (Term f l) u (i :: q) = Term f (replace_at_pos_list l u i q).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="replace_at_pos_is_replace_at_pos1"></a>replace_at_pos_is_replace_at_pos1 :<br/>
&nbsp;&nbsp;forall t u p, is_a_pos t p = true -&gt;<br/>
&nbsp;&nbsp;subterm_at_pos (replace_at_pos t u p) p = Some u.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="replace_at_pos_is_replace_at_pos2"></a>replace_at_pos_is_replace_at_pos2 :<br/>
&nbsp;&nbsp;forall t p u, subterm_at_pos t p = Some u -&gt; replace_at_pos t u p = t.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subterm_at_pos_apply_subst_apply_subst_subterm_at_pos"></a>subterm_at_pos_apply_subst_apply_subst_subterm_at_pos :<br/>
&nbsp;&nbsp;forall t p sigma, <br/>
&nbsp;&nbsp;match subterm_at_pos t p with<br/>
&nbsp;&nbsp;| Some u =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subterm_at_pos (apply_subst sigma t) p = Some (apply_subst sigma u)<br/>
&nbsp;&nbsp;| None =&gt; True<br/>
end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="replace_at_pos_list_replace_at_pos_in_subterm"></a>replace_at_pos_list_replace_at_pos_in_subterm :<br/>
forall l1 ui l2 u i p, length l1 = i -&gt;<br/>
&nbsp;replace_at_pos_list (l1 ++ ui :: l2) u i p = <br/>
&nbsp;l1 ++ (replace_at_pos ui u p) :: l2.<br/>

<br/>
<span class="keyword">End</span> Make.<br/>

<br/>
</code>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://coq.inria.fr">coqdoc</a></font>
</div>

</div>

</body>
</html>