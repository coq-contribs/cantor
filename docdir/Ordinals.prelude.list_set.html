<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Ordinals.prelude.list_set</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Ordinals.prelude.list_set</h1>

<code>
</code>

<div class="doc">
<a name="lab10"></a><h1>Sets built with lists</h1 class="section">

</div>
<code>

<br/>

<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> List.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="Ordinals.prelude.more_list.html">more_list</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="Ordinals.prelude.list_permut.html">list_permut</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Arith.<br/>

<br/>
<span class="keyword">Module</span> Type <a name="S"></a>S.<br/>

<br/>
Declare <span class="keyword">Module</span> <a name="DS"></a>DS : decidable_set.S.<br/>

<br/>
<span class="keyword">Definition</span> <a name="elt"></a>elt := DS.A.<br/>
<span class="keyword">Definition</span> <a name="eq_elt_dec"></a>eq_elt_dec := DS.eq_A_dec.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="without_red"></a>without_red (l : list elt) {struct l} : Prop :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; True<br/>
&nbsp;&nbsp;| e :: le =&gt; if (In_dec eq_elt_dec e le) then False else without_red le<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Record</span> <a name="t"></a>t : Set :=<br/>
&nbsp;&nbsp;mk_set <br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;support : list elt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_a_set : without_red support<br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="keyword">Definition</span> <a name="cardinal"></a>cardinal s := List.length s.(support).<br/>

<br/>
<span class="keyword">Definition</span> <a name="subset"></a>subset s1 s2 : Prop :=<br/>
&nbsp;&nbsp;forall e, In e s1.(support) -&gt; In e s2.(support).<br/>

<br/>
<span class="keyword">Axiom</span> <a name="cardinal_subset"></a>cardinal_subset :<br/>
&nbsp;&nbsp;forall s1 s2, subset s1 s2 -&gt; cardinal s1 &lt;= cardinal s2.<br/>

<br/>
<span class="keyword">End</span> S.<br/>

<br/>
</code>

<div class="doc">
<a name="lab11"></a><h2>Definition of sets using lists.</h2 class="section">

</div>
<code>
<span class="keyword">Module</span> <a name="Make"></a>Make (DS1 : decidable_set.S) &lt;: S with <span class="keyword">Module</span> <a name="DS"></a>DS:= DS1.<br/>

<br/>
<span class="keyword">Module</span> <a name="DS"></a>DS := DS1.<br/>
<span class="keyword">Import</span> DS1.<br/>
<span class="keyword">Module</span> <a name="LP"></a>LP := list_permut.Make (DS1).<br/>

<br/>
<span class="keyword">Definition</span> <a name="elt"></a>elt := DS.A.<br/>
<span class="keyword">Definition</span> <a name="eq_elt_dec"></a>eq_elt_dec : forall t1 t2 : elt, {t1 = t2} + {t1 &lt;&gt; t2} := DS.eq_A_dec.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="without_red"></a>without_red (l : list elt) {struct l} : Prop :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; True<br/>
&nbsp;&nbsp;| e :: le =&gt; if (In_dec eq_elt_dec e le) then False else without_red le<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Record</span> <a name="t"></a>t : Set :=<br/>
&nbsp;&nbsp;mk_set <br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;support : list elt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_a_set : without_red support<br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="keyword">Definition</span> <a name="mem"></a>mem e s := In e s.(support).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="mem_dec"></a>mem_dec : forall e s, {mem e s}+{~mem e s}.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="add_prf"></a>add_prf :<br/>
&nbsp;&nbsp;forall e l, without_red l -&gt; ~In e l -&gt; without_red (e :: l).<br/>

<br/>
<span class="keyword">Definition</span> <a name="add"></a>add e s :=<br/>
&nbsp;&nbsp;match In_dec eq_elt_dec e s.(support) with<br/>
&nbsp;&nbsp;| left _ =&gt; s<br/>
&nbsp;&nbsp;| right R =&gt; mk_set (e :: s.(support)) (add_prf e s.(support) s.(is_a_set) R)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="add_1"></a>add_1 : forall e s, mem e (add e s).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="add_2"></a>add_2 : forall e e' s, mem e s -&gt; mem e (add e' s).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="add_12"></a>add_12 : forall e e' s, mem e (add e' s) -&gt; e = e' \/ mem e s.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="filter_aux"></a>filter_aux (P : elt -&gt; Prop) (P_dec : forall e, {P e}+{~ P e})<br/>
&nbsp;&nbsp;&nbsp;(l : list elt) {struct l} : list elt :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; nil<br/>
&nbsp;&nbsp;| e :: le =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (P_dec e)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then e :: (filter_aux P P_dec le) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else filter_aux P P_dec le<br/>
&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="included_filter_aux"></a>included_filter_aux : <br/>
forall P P_dec e l, In e (filter_aux P P_dec l) -&gt; In e l.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_filter_aux"></a>without_red_filter_aux :  <br/>
&nbsp;&nbsp;forall P P_dec l, without_red l -&gt; without_red (filter_aux P P_dec l).<br/>

<br/>
<span class="keyword">Definition</span> <a name="filter"></a>filter P P_dec s := <br/>
&nbsp;&nbsp;&nbsp;mk_set (filter_aux P P_dec s.(support))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(without_red_filter_aux P P_dec _ s.(is_a_set)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="filter_1_list"></a>filter_1_list :<br/>
&nbsp;&nbsp;forall (P : elt -&gt; Prop) P_dec l e, In e l -&gt; P e -&gt; In e (filter_aux P P_dec l).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="filter_1"></a>filter_1 :<br/>
&nbsp;&nbsp;forall (P : elt -&gt; Prop) P_dec s e, mem e s -&gt; P e -&gt; mem e (filter P P_dec s).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="filter_2_list"></a>filter_2_list :<br/>
&nbsp;forall (P : elt -&gt; Prop) P_dec l e, In e (filter_aux P P_dec l) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In e l /\ P e.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="filter_2"></a>filter_2 :<br/>
&nbsp;forall (P : elt -&gt; Prop) P_dec s e, mem e (filter P P_dec s) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mem e s /\ P e.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="remove_red"></a>remove_red (l : list elt) : list elt :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; nil<br/>
&nbsp;&nbsp;| e :: le =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (In_dec eq_elt_dec e le) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then remove_red le <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else e :: (remove_red le)<br/>
&nbsp;&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="included_remove_red"></a>included_remove_red : <br/>
forall e l, In e (remove_red l) -&gt; In e l.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="remove_red_included"></a>remove_red_included : forall e l, In e l -&gt; In e (remove_red l).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_remove_red"></a>without_red_remove_red :  forall l, without_red (remove_red l).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_remove"></a>without_red_remove :<br/>
&nbsp;&nbsp;forall e l1 l2, without_red (l1 ++ e :: l2) -&gt; without_red (l1 ++ l2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_add"></a>without_red_add :<br/>
&nbsp;&nbsp;forall e l1 l2, without_red (l1 ++ l2) -&gt; ~In e (l1 ++ l2) -&gt;<br/>
&nbsp;&nbsp;without_red (l1 ++ e :: l2).<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_nil"></a>without_red_nil : without_red nil.<br/>

<br/>
<span class="keyword">Definition</span> <a name="empty"></a>empty : t :=<br/>
&nbsp;&nbsp;mk_set nil without_red_nil.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_singleton"></a>without_red_singleton : forall e : elt, without_red (e :: nil).<br/>

<br/>
<span class="keyword">Definition</span> <a name="singleton"></a>singleton (e : elt) : t :=<br/>
&nbsp;&nbsp;mk_set (e :: nil) (without_red_singleton e).<br/>

<br/>
<span class="keyword">Definition</span> <a name="make_set"></a>make_set (l : list elt) : t :=<br/>
&nbsp;&nbsp;mk_set (remove_red l) (without_red_remove_red l).<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="add_without_red"></a>add_without_red (acc l : list elt) {struct l} : list elt :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; acc<br/>
&nbsp;&nbsp;| e :: le =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (In_dec eq_elt_dec e acc)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then add_without_red acc le<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else add_without_red (e :: acc) le<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_add_without_red"></a>without_red_add_without_red :<br/>
&nbsp;&nbsp;forall l1 l2, without_red l1 -&gt; without_red (add_without_red l1 l2).<br/>

<br/>
<span class="keyword">Definition</span> <a name="union"></a>union s1 s2 :=<br/>
&nbsp;&nbsp;mk_set (add_without_red s1.(support) s2.(support))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(without_red_add_without_red s1.(support) s2.(support) s1.(is_a_set)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_1_aux"></a>union_1_aux :<br/>
forall (l1 l2 : list elt) (e : elt), In e l1 -&gt; In e (add_without_red l1 l2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_1"></a>union_1 : forall s1 s2 e, mem e s1 -&gt; mem e (union s1 s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_2_aux"></a>union_2_aux :<br/>
forall (l1 l2 : list elt) (e : elt), In e l2 -&gt; In e (add_without_red l1 l2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_2"></a>union_2 : forall s1 s2 e, mem e s2 -&gt; mem e (union s1 s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_12_aux"></a>union_12_aux :<br/>
forall (l1 l2 : list elt) (e : elt), In e (add_without_red l1 l2) -&gt; In e l1 \/ In e l2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_12"></a>union_12 : <br/>
&nbsp;&nbsp;forall s1 s2 e, mem e (union s1 s2) -&gt; mem e s1 \/ mem e s2.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="remove_not_common"></a>remove_not_common (acc l1 l2 : list elt) {struct l2} : list elt :=<br/>
&nbsp;&nbsp;match l2 with<br/>
&nbsp;&nbsp;| nil =&gt; acc<br/>
&nbsp;&nbsp;| e :: l =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if In_dec eq_elt_dec e l1 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then remove_not_common (e :: acc) l1 l<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else remove_not_common acc l1 l<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_remove_not_common_aux"></a>without_red_remove_not_common_aux :<br/>
&nbsp;&nbsp;forall acc l1 l2, (forall e, In e acc /\ In e l2 -&gt; False) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;without_red acc -&gt; without_red l1 -&gt; without_red l2 -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;without_red (remove_not_common acc l1 l2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_remove_not_common"></a>without_red_remove_not_common :<br/>
&nbsp;&nbsp;forall l1 l2, without_red l1 -&gt; without_red l2 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;without_red (remove_not_common nil l1 l2).<br/>

<br/>
<span class="keyword">Definition</span> <a name="inter"></a>inter s1 s2 :=<br/>
&nbsp;&nbsp;mk_set (remove_not_common nil s1.(support) s2.(support)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(without_red_remove_not_common _ _ s1.(is_a_set) s2.(is_a_set)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="inter_1_aux"></a>inter_1_aux : <br/>
&nbsp;&nbsp;forall acc l1 l2 e, In e (remove_not_common acc l1 l2) -&gt; In e acc \/ In e l1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="inter_1"></a>inter_1 : forall s1 s2 e, mem e (inter s1 s2) -&gt; mem e s1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="inter_2_aux"></a>inter_2_aux : <br/>
&nbsp;&nbsp;forall acc l1 l2 e, In e (remove_not_common acc l1 l2) -&gt; In e acc \/ In e l2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="inter_2"></a>inter_2 : forall s1 s2 e, mem e (inter s1 s2) -&gt; mem e s2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="inter_12_aux"></a>inter_12_aux :<br/>
&nbsp;&nbsp;forall acc l1 l2 e,  In e l1 -&gt; In e l2 -&gt; In e (remove_not_common acc l1 l2).<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="inter_12"></a>inter_12 : <br/>
&nbsp;&nbsp;forall s1 s2 e, mem e s1 -&gt; mem e s2 -&gt; mem e (inter s1 s2).<br/>

<br/>
<span class="keyword">Definition</span> <a name="subset"></a>subset s1 s2 : Prop :=<br/>
&nbsp;&nbsp;forall e, mem e s1 -&gt; mem e s2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_dec"></a>subset_dec : forall s1 s2, {subset s1 s2} + {~ subset s1 s2}.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_union_1"></a>subset_union_1 :<br/>
&nbsp;&nbsp;forall s1 s2, subset s1 (union s1 s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_union_2"></a>subset_union_2 :<br/>
&nbsp;&nbsp;forall s1 s2, subset s2 (union s1 s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_inter_1"></a>subset_inter_1 :<br/>
&nbsp;&nbsp;forall s1 s2, subset (inter s1 s2) s1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_inter_2"></a>subset_inter_2 :<br/>
&nbsp;&nbsp;forall s1 s2, subset (inter s1 s2) s2.<br/>

<br/>
<span class="keyword">Definition</span> <a name="eq_set"></a>eq_set s1 s2 :=<br/>
&nbsp;&nbsp;forall e, mem e s1 &lt;-&gt; mem e s2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="eq_set_dec"></a>eq_set_dec : forall s1 s2, {eq_set s1 s2} + {~eq_set s1 s2}.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="eq_set_refl"></a>eq_set_refl : forall s, eq_set s s.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="eq_set_sym"></a>eq_set_sym :<br/>
&nbsp;&nbsp;forall s1 s2, eq_set s1 s2 -&gt; eq_set s2 s1.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="eq_set_trans"></a>eq_set_trans :<br/>
&nbsp;&nbsp;forall s1 s2 s3, eq_set s1 s2 -&gt; eq_set s2 s3 -&gt; eq_set s1 s3.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="add_comm"></a>add_comm :<br/>
&nbsp;&nbsp;forall e1 e2 s, eq_set (add e1 (add e2 s)) (add e2 (add e1 s)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_empty_1"></a>union_empty_1 :<br/>
&nbsp;&nbsp;forall s, eq_set s (union empty s).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_empty_2"></a>union_empty_2 :<br/>
&nbsp;&nbsp;forall s, eq_set s (union s empty).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_comm"></a>union_comm :<br/>
&nbsp;&nbsp;forall s1 s2, eq_set (union s1 s2) (union s2 s1).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_assoc"></a>union_assoc :<br/>
&nbsp;&nbsp;forall s1 s2 s3, eq_set (union s1 (union s2 s3)) (union (union s1 s2) s3).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="filter_union"></a>filter_union :<br/>
&nbsp;&nbsp;forall P P_dec s1 s2, <br/>
&nbsp;&nbsp;eq_set (filter P P_dec (union s1 s2))  (union (filter P P_dec s1) (filter P P_dec s2)).<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_filter"></a>subset_filter :<br/>
&nbsp;&nbsp;forall (P1 P2 : elt -&gt; Prop) P1_dec P2_dec s1 s2, subset s1 s2 -&gt;<br/>
&nbsp;&nbsp;(forall e, P1 e -&gt; P2 e) -&gt; subset (filter P1 P1_dec s1) (filter P2 P2_dec s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_compat_1"></a>subset_compat_1 :<br/>
&nbsp;&nbsp;forall s1 s1' s2, eq_set s1 s1' -&gt; subset s1 s2 -&gt; subset s1' s2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_compat_2"></a>subset_compat_2 :<br/>
&nbsp;&nbsp;forall s1 s2 s2', eq_set s2 s2' -&gt; subset s1 s2 -&gt; subset s1 s2'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_compat"></a>subset_compat :<br/>
&nbsp;&nbsp;&nbsp;forall s1 s1' s2 s2', eq_set s1 s1' -&gt; eq_set s2 s2' -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subset s1 s2 -&gt; subset s1' s2'.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_compat_subset_1"></a>union_compat_subset_1 :<br/>
&nbsp;&nbsp;forall s1 s2 s, subset s1 s2 -&gt; subset (union s1 s)  (union s2 s).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_compat_subset_2"></a>union_compat_subset_2 :<br/>
&nbsp;&nbsp;forall s1 s2 s, subset s1 s2 -&gt; subset (union s s1)  (union s s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="union_compat_eq_set"></a>union_compat_eq_set :<br/>
&nbsp;&nbsp;forall s1 s1' s2 s2', eq_set s1 s1' -&gt; eq_set s2 s2' -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;eq_set (union s1 s2) (union s1' s2').<br/>

<br/>
<span class="keyword">Lemma</span>  <a name="subset_subset_union"></a>subset_subset_union :<br/>
&nbsp;&nbsp;forall s1 s2 s, subset s1 s -&gt; subset s2 s -&gt; subset (union s1 s2) s.<br/>

<br/>
<span class="keyword">Definition</span> <a name="cardinal"></a>cardinal s := List.length s.(support).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="cardinal_subset"></a>cardinal_subset :<br/>
&nbsp;&nbsp;forall s1 s2, subset s1 s2 -&gt; cardinal s1 &lt;= cardinal s2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="cardinal_union_1"></a>cardinal_union_1 :<br/>
&nbsp;&nbsp;forall s1 s2, cardinal s1 &lt;= cardinal (union s1 s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="cardinal_union_2"></a>cardinal_union_2 :<br/>
&nbsp;&nbsp;forall s1 s2, cardinal s2 &lt;= cardinal (union s1 s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="cardinal_union_inter_12"></a>cardinal_union_inter_12 :<br/>
&nbsp;&nbsp;forall s1 s2, cardinal (union s1 s2) + cardinal (inter s1 s2) = cardinal s1 + cardinal s2.<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="cardinal_union"></a>cardinal_union:<br/>
&nbsp;&nbsp;forall s1 s2, cardinal (union s1 s2) = cardinal s1 + cardinal s2 -cardinal (inter s1 s2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="cardinal_eq_set"></a>cardinal_eq_set : forall s1 s2, eq_set s1 s2 -&gt; cardinal s1 = cardinal s2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="subset_cardinal_not_eq_not_eq_set"></a>subset_cardinal_not_eq_not_eq_set  :<br/>
&nbsp;forall s1 s2 e, subset s1 s2 -&gt; ~mem e s1 -&gt; mem e s2  -&gt; <br/>
&nbsp;&nbsp;cardinal s1 &lt; cardinal s2.<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="eq_set_list_permut_support"></a>eq_set_list_permut_support :<br/>
&nbsp;&nbsp;forall s1 s2,  eq_set s1 s2 -&gt; LP.list_permut s1.(support) s2.(support).<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="without_red_permut"></a>without_red_permut :<br/>
&nbsp;forall l1 l2, without_red l1 -&gt; LP.list_permut l1 l2 -&gt; without_red l2.<br/>

<br/>
<span class="keyword">End</span> Make.<br/>
</code>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://coq.inria.fr">coqdoc</a></font>
</div>

</div>

</body>
</html>