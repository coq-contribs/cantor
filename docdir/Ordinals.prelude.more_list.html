<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Ordinals.prelude.more_list</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Ordinals.prelude.more_list</h1>

<code>
</code>

<div class="doc">
<a name="lab12"></a><h1>Some additional properties for the Coq lists.</h1 class="section">

</div>
<code>

<br/>

<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> List.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Arith.<br/>

<br/>
</code>

<div class="doc">
<a name="lab13"></a><h2>Relations between length, map, append, In and nth.</h2 class="section">

</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="map_map"></a>map_map :<br/>
&nbsp;&nbsp;forall (A B C : Set) (l : (list A)) (f : B -&gt; C) (g : A -&gt;B),<br/>
&nbsp;&nbsp;map f (map g l) = map (fun x =&gt; f (g x)) l.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_app_length"></a>list_app_length :<br/>
&nbsp;forall A, forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="length_map"></a>length_map :<br/>
&nbsp;forall (A B : Set) (f : A -&gt; B) (l : list A), length (map f l) = length l.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="map_app"></a>map_app :<br/>
&nbsp;forall (A B : Set) (f : A -&gt; B) l1 l2, map f (l1 ++ l2) = (map f l1) ++ (map f l2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="in_in_map"></a>in_in_map :<br/>
&nbsp;&nbsp;forall (A B : Set) (f : A -&gt; B) a l, In a l -&gt; In (f a) (map f l).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="in_map_in"></a>in_map_in :<br/>
&nbsp;&nbsp;forall (A B : Set) (f : A -&gt; B) b l, In b (map f l) -&gt;<br/>
&nbsp;&nbsp;exists a, In a l /\ f a = b.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="nth_error_map"></a>nth_error_map :<br/>
&nbsp;&nbsp;forall (A B : Set) (f : A -&gt; B) (l : list A) i,<br/>
&nbsp;&nbsp;match nth_error (map f l) i with<br/>
&nbsp;&nbsp;| Some f_li =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match nth_error l i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some li =&gt; f_li = f li<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; False<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;| None =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match nth_error l i with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some li =&gt; False<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; True<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
end.<br/>

<br/>
</code>

<div class="doc">
<a name="lab14"></a><h2>A measure on lists based on a measure on elements.</h2 class="section">

</div>
<code>

<br/>
<span class="keyword">Fixpoint</span> <a name="list_size"></a>list_size (A : Set) (size : A -&gt; nat) (l : list A) {struct l} : nat :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; 0<br/>
&nbsp;&nbsp;| h :: tl =&gt; size h + list_size size tl<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_size_tl_compat"></a>list_size_tl_compat :<br/>
&nbsp;&nbsp;forall (A : Set) (size : A -&gt; nat) a b l, size a &lt; size b -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;list_size size (a :: l) &lt; list_size size (b :: l).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_size_app"></a>list_size_app:<br/>
&nbsp;forall (A : Set) (size : A -&gt; nat) l1 l2,<br/>
&nbsp;list_size size (l1 ++ l2) = list_size size l1 + list_size size l2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_size_fold"></a>list_size_fold :<br/>
&nbsp;&nbsp;forall (A : Set) (size : A -&gt; nat) l n,<br/>
&nbsp;&nbsp;fold_left (fun (size_acc : nat) (a : A) =&gt; size_acc + size a) l n =<br/>
&nbsp;&nbsp;n + list_size size l.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_size_size_eq"></a>list_size_size_eq :<br/>
&nbsp;&nbsp;forall (A : Set) (size1 : A -&gt; nat) (size2 : A -&gt; nat) l,<br/>
&nbsp;(forall a, In a l -&gt; size1 a = size2 a) -&gt; list_size size1 l = list_size size2 l.<br/>

<br/>
</code>

<div class="doc">
<a name="lab15"></a><h2>Induction principles for list.</h2 class="section">

 Induction on the length. 
</div>
<code>
<span class="keyword">Definition</span> <a name="list_rec2"></a>list_rec2 :<br/>
&nbsp;&nbsp;forall A, forall P : list A -&gt; Type,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall (n:nat) (l : list A), length l &lt;= n -&gt; P l) -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall l : list A, P l.<br/>

<br/>
<span class="keyword">Definition</span> <a name="o_length"></a>o_length (A : Set) (l1 l2 : list A) : Prop := length l1 &lt; length l2.<br/>

<br/>
<span class="keyword">Theorem</span> <a name="well_founded_length"></a>well_founded_length : forall A, well_founded (o_length (A := A)).<br/>

<br/>

<br/>
</code>

<div class="doc">
Induction on the the size. 
</div>
<code>
<span class="keyword">Definition</span> <a name="list_rec3"></a>list_rec3 (A : Set) (size : A -&gt; nat) :<br/>
&nbsp;&nbsp;forall P : list A -&gt; Type,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(forall (n:nat) (l : list A), list_size size l &lt;= n -&gt; P l) -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;forall l : list A, P l.<br/>

<br/>
</code>

<div class="doc">
<a name="lab16"></a><h2>How to remove an element in a list, whenever it is present.</h2 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="split_list"></a>split_list (A : Set)<br/>
&nbsp;&nbsp;(eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(l : list A) (t : A) {struct l} : list A * list A :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; (nil, nil)<br/>
&nbsp;&nbsp;| a :: l' =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if eqA t a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then (nil, l')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else let (l1,l2) := split_list eqA l' t in (a :: l1, l2)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="split_list_app_cons"></a>split_list_app_cons :<br/>
&nbsp;forall (A : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) t l,<br/>
&nbsp;&nbsp;&nbsp;In t l -&gt; let (l1, l2) := split_list eqA l t in l = l1 ++ t :: l2.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="remove"></a>remove (A : Set) (eqA : forall a1 a2 : A, {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(a : A) (l : list A) {struct l} : (option (list A)) :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; None <br/>
&nbsp;&nbsp;| h :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if eqA a h<br/>
&nbsp;&nbsp;&nbsp;&nbsp;then Some tl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match remove eqA a tl with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some rmv =&gt; Some (h :: rmv)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="in_remove"></a>in_remove :<br/>
&nbsp;&nbsp;forall (A : Set) (eqA : forall a1 a2 : A, {a1=a2}+{a1&lt;&gt;a2}) a l,  <br/>
&nbsp;&nbsp;match remove eqA a l with<br/>
&nbsp;&nbsp;| None =&gt; ~In a l<br/>
&nbsp;&nbsp;| Some l' =&gt; In a l /\ let (l1, l2) := split_list eqA l a in l' = l1 ++ l2<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="remove_list"></a>remove_list (A : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2})<br/>
(la l : list A) {struct l} : option (list A) :=<br/>
&nbsp;&nbsp;match la with<br/>
&nbsp;&nbsp;| nil =&gt; Some l<br/>
&nbsp;&nbsp;| a :: la' =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match l with <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| b :: l' =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if eqA a b<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then remove_list eqA la' l'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match remove_list eqA la l' with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; None<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some rmv =&gt; Some (b :: rmv)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;end.<br/>

<br/>
</code>

<div class="doc">
<a name="lab17"></a><h2>Iterators.</h2 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="fold_left2"></a>fold_left2 (A B C : Set) (f : A -&gt; B -&gt; C -&gt; A) (a : A) (l1 : list B) (l2 : list C)  <br/>
&nbsp;&nbsp;{struct l1} : option A :=<br/>
&nbsp;&nbsp;match l1, l2 with<br/>
&nbsp;&nbsp;| nil, nil =&gt; Some a<br/>
&nbsp;&nbsp;| b :: t1, c :: t2 =&gt; fold_left2 f (f a b c) t1 t2<br/>
&nbsp;&nbsp;| _, _ =&gt; None<br/>
&nbsp;&nbsp;end.<br/>

<br/>
</code>

<div class="doc">
<a name="lab18"></a><h2>more properties on the nth element.</h2 class="section">

</div>
<code>
<span class="keyword">Lemma</span> <a name="nth_error_ok_in"></a>nth_error_ok_in :<br/>
&nbsp;&nbsp;forall (A : Set) n (l : list A) (a : A),<br/>
&nbsp;&nbsp;nth_error l n = Some a -&gt; In a l.<br/>

<br/>
</code>

<div class="doc">
<a name="lab19"></a><h2>Association lists.</h2 class="section">

<a name="lab20"></a><h3>find.</h3 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="find"></a>find (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2})<br/>
(a : A) (l : list (A * B)) {struct l} : option (B) :=<br/>
&nbsp;match l with<br/>
&nbsp;| nil =&gt; None<br/>
&nbsp;| (a1,b1) :: l =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if eqA a a1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then Some b1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else find eqA a l<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="find_not_mem"></a>find_not_mem :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2})<br/>
&nbsp;&nbsp;(a : A) (b : B) (l : list (A * B)) (dom : list A),<br/>
&nbsp;&nbsp;~In a dom -&gt; (forall a', In a' dom -&gt; find eqA a' ((a,b) :: l) = find eqA a' l).<br/>

<br/>
</code>

<div class="doc">
<a name="lab21"></a><h3>number of occurences of the first element of a pair.</h3 class="section">

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="nb_occ"></a>nb_occ (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2})<br/>
&nbsp;&nbsp;(a : A) (l : list (A * B)) {struct l} : nat :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; 0<br/>
&nbsp;&nbsp;| (a',_) :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (eqA a a') then S (nb_occ eqA a tl) else nb_occ eqA a tl<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="none_nb_occ_O"></a>none_nb_occ_O :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2})<br/>
&nbsp;&nbsp;(a : A) (l : list (A * B)),<br/>
&nbsp;&nbsp;find eqA a l = None -&gt; nb_occ eqA a l = 0.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="some_nb_occ_Sn"></a>some_nb_occ_Sn :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2})<br/>
&nbsp;&nbsp;(a : A) (l : list (A * B)) b,<br/>
&nbsp;&nbsp;find eqA a l = Some b -&gt; 1 &lt;= nb_occ eqA a l.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="nb_occ_app"></a>nb_occ_app :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2})<br/>
&nbsp;&nbsp;a (l1 l2 : list (A * B)), <br/>
&nbsp;&nbsp;nb_occ eqA a (l1++l2) = nb_occ eqA a l1 + nb_occ eqA a l2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="reduce_assoc_list"></a>reduce_assoc_list :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}),<br/>
&nbsp;&nbsp;forall (l : list (A * B)), exists l', <br/>
&nbsp;(forall a, nb_occ eqA a l' &lt;= 1) /\ (forall a, find eqA a l = find eqA a l').<br/>

<br/>
</code>

<div class="doc">
map_without_repetition applies a function to the elements of a list,
but only a single time when there are several consecutive occurences of the
same element. Moreover, the function is supposed to return an option as a result,
in order to simulate exceptions, and the abnormal results are discarted.

</div>
<code>
<span class="keyword">Fixpoint</span> <a name="map_without_repetition"></a>map_without_repetition (A B : Set) <br/>
&nbsp;&nbsp;(eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(f : A -&gt; option B) (l : list A) {struct l} : list B :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; (nil : list B)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| h :: nil =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match f h with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some f_h =&gt; f_h :: nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| h1 :: ((h2 :: tl) as l1) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (eqA h1 h2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;then map_without_repetition eqA f l1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match f h1 with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; map_without_repetition eqA f l1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some f_h1 =&gt; f_h1 :: (map_without_repetition eqA f l1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="prop_map_without_repetition"></a>prop_map_without_repetition :<br/>
&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(P : B -&gt; Prop) f l,<br/>
&nbsp;&nbsp;(forall a, In a l -&gt; <br/>
&nbsp;&nbsp;&nbsp;match f a with <br/>
&nbsp;&nbsp;&nbsp;| None =&gt; True <br/>
&nbsp;&nbsp;&nbsp;| Some f_a =&gt; P f_a<br/>
&nbsp;&nbsp;&nbsp;end) -&gt;<br/>
&nbsp;&nbsp;&nbsp;(forall b, In b (map_without_repetition eqA f l) -&gt; P b).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exists_map_without_repetition"></a>exists_map_without_repetition :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(P : B -&gt; Prop) f l,<br/>
&nbsp;&nbsp;(exists a,  In a l /\ match f a with <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| None =&gt; False<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| Some f_a =&gt; P f_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end) -&gt;<br/>
&nbsp;&nbsp;(exists b, In b (map_without_repetition eqA f l) /\ P b).<br/>

<br/>
</code>

<div class="doc">
map12_without_repetition is similar to map_without_repetition, but the 
applied function returns two optional results instead of one.

</div>
<code>

<br/>
<span class="keyword">Fixpoint</span> <a name="map12_without_repetition"></a>map12_without_repetition (A B : Set) <br/>
&nbsp;&nbsp;(eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(f : A -&gt; option B * option B) (l : list A) {struct l} : list B :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| nil =&gt; (nil : list B)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| h :: nil =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match f h with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (None, None) =&gt; nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (Some f_h1, None) =&gt; f_h1 :: nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (None, Some f_h1) =&gt; f_h1 :: nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (Some f_h1, Some f_h2) =&gt; f_h1 :: f_h2 :: nil<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| h :: ((h' :: tl) as l1) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if (eqA h h')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;then map12_without_repetition eqA f l1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match f h with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (None, None) =&gt; map12_without_repetition eqA f l1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (Some f_h1, None) =&gt; f_h1 :: (map12_without_repetition eqA f l1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (None, Some f_h1) =&gt; f_h1 :: (map12_without_repetition eqA f l1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (Some f_h1, Some f_h2) =&gt; f_h2 :: f_h1 :: (map12_without_repetition eqA f l1)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end<br/>
end.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="prop_map12_without_repetition"></a>prop_map12_without_repetition :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(P : B -&gt; Prop) f l,<br/>
&nbsp;&nbsp;(forall a, In a l -&gt; <br/>
&nbsp;&nbsp;&nbsp;match f a with <br/>
&nbsp;&nbsp;&nbsp;| (None, None) =&gt; True <br/>
&nbsp;&nbsp;&nbsp;| (Some f1_a, None) =&gt; P f1_a<br/>
&nbsp;&nbsp;&nbsp;| (None, Some f2_a) =&gt; P f2_a<br/>
&nbsp;&nbsp;&nbsp;| (Some f1_a, Some f2_a) =&gt; P f1_a /\ P f2_a<br/>
&nbsp;&nbsp;&nbsp;end) -&gt;<br/>
&nbsp;(forall b, In b (map12_without_repetition eqA f l) -&gt; P b).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="exists_map12_without_repetition"></a>exists_map12_without_repetition :<br/>
&nbsp;&nbsp;forall (A B : Set) (eqA : forall (a1 a2 : A), {a1=a2}+{a1&lt;&gt;a2}) <br/>
&nbsp;&nbsp;(P : B -&gt; Prop) f l,<br/>
&nbsp;&nbsp;((exists a, In a l /\ match f a with <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (None, None) =&gt; False<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (None, Some f2_a) =&gt; P f2_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (Some f1_a, None) =&gt; P f1_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (Some f1_a, Some f2_a) =&gt; P f1_a \/ P f2_a<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end) -&gt;<br/>
&nbsp;&nbsp;(exists b, In b (map12_without_repetition eqA f l) /\ P b)).<br/>
</code>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://coq.inria.fr">coqdoc</a></font>
</div>

</div>

</body>
</html>