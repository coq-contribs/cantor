<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Ordinals.prelude.list_permut</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Ordinals.prelude.list_permut</h1>

<code>
</code>

<div class="doc">
<a name="lab4"></a><h1>Permutation over lists, and finite multisets.</h1 class="section">

</div>
<code>

<br/>

<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="Ordinals.prelude.decidable_set.html">decidable_set</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> List.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> <a class="modref" href="Ordinals.prelude.more_list.html">more_list</a>.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Multiset.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Arith.<br/>
<span class="keyword">Require</span> <span class="keyword">Import</span> Setoid.<br/>

<br/>
<span class="keyword">Module</span> Type <a name="Permut"></a>Permut.<br/>

<br/>
Declare <span class="keyword">Module</span> <a name="DS"></a>DS : decidable_set.S.<br/>

<br/>
<span class="keyword">Definition</span> <a name="elt"></a>elt := DS.A.<br/>
<span class="keyword">Definition</span> <a name="eq_elt_dec"></a>eq_elt_dec := DS.eq_A_dec.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="list_to_multiset"></a>list_to_multiset (l : list elt) {struct l} : multiset elt :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; EmptyBag elt<br/>
&nbsp;&nbsp;| h :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;munion (SingletonBag _ eq_elt_dec h) (list_to_multiset tl)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Definition</span> <a name="list_permut"></a>list_permut (l1 l2:list elt) : Prop :=<br/>
&nbsp;&nbsp;meq (list_to_multiset l1) (list_to_multiset l2).<br/>

<br/>
<span class="keyword">End</span> Permut.<br/>

<br/>
</code>

<div class="doc">
<a name="lab5"></a><h2>Definition of permutation over lists.</h2 class="section">

</div>
<code>
<span class="keyword">Module</span> <a name="Make"></a>Make (DS1 : decidable_set.S) &lt;: Permut with <span class="keyword">Module</span> <a name="DS"></a>DS:= DS1.<br/>

<br/>
<span class="keyword">Module</span> <a name="DS"></a>DS := DS1.<br/>
<span class="keyword">Import</span> DS1.<br/>

<br/>
<span class="keyword">Definition</span> <a name="elt"></a>elt := DS.A.<br/>
<span class="keyword">Definition</span> <a name="eq_elt_dec"></a>eq_elt_dec : forall t1 t2 : elt, {t1 = t2} + {t1 &lt;&gt; t2} := DS.eq_A_dec.<br/>

<br/>
<span class="keyword">Fixpoint</span> <a name="list_to_multiset"></a>list_to_multiset (l : list elt) {struct l} : multiset elt :=<br/>
&nbsp;&nbsp;match l with<br/>
&nbsp;&nbsp;| nil =&gt; EmptyBag elt<br/>
&nbsp;&nbsp;| h :: tl =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;munion (SingletonBag _ eq_elt_dec h) (list_to_multiset tl)<br/>
&nbsp;&nbsp;end.<br/>

<br/>
<span class="keyword">Definition</span> <a name="list_permut"></a>list_permut (l1 l2:list elt) : Prop :=<br/>
&nbsp;&nbsp;meq (list_to_multiset l1) (list_to_multiset l2).<br/>

<br/>
</code>

<div class="doc">
Properties over the multiplicity. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="multiplicity_app"></a>multiplicity_app :<br/>
&nbsp;forall (l1 l2:list elt) (t : elt),<br/>
&nbsp;&nbsp;&nbsp;multiplicity (list_to_multiset (l1 ++ l2)) t =<br/>
&nbsp;&nbsp;&nbsp;multiplicity (list_to_multiset l1) t + multiplicity (list_to_multiset l2) t.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="out_mult_O"></a>out_mult_O :<br/>
&nbsp;&nbsp;forall (t : elt) (l:list elt), ~ In t l -&gt; multiplicity (list_to_multiset l) t = 0.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="in_mult_S"></a>in_mult_S :<br/>
&nbsp;forall (t : elt) (l : list elt), In t l -&gt; multiplicity (list_to_multiset l) t &gt;= 1.<br/>

<br/>
</code>

<div class="doc">
<a name="lab6"></a><h2>Permutation is a equivalence relation.</h2 class="section">

Reflexivity. 
</div>
<code>
<span class="keyword">Theorem</span> <a name="list_permut_refl"></a>list_permut_refl :<br/>
&nbsp;forall (l : list elt), list_permut l l.<br/>

<br/>
</code>

<div class="doc">
Symetry. 
</div>
<code>
<span class="keyword">Theorem</span> <a name="list_permut_sym"></a>list_permut_sym :<br/>
&nbsp;forall l1 l2 : list elt, list_permut l1 l2 -&gt; list_permut l2 l1.<br/>

<br/>
<span class="keyword">Hint</span> <span class="keyword">Immediate</span> list_permut_refl.<br/>
<span class="keyword">Hint</span> Resolve list_permut_sym.<br/>

<br/>
</code>

<div class="doc">
Transitivity. 
</div>
<code>
<span class="keyword">Theorem</span> <a name="list_permut_trans"></a>list_permut_trans :<br/>
&nbsp;&nbsp;forall l1 l2 l3 : list elt, list_permut l1 l2 -&gt; list_permut l2 l3 -&gt; list_permut l1 l3.<br/>

<br/>
Add Relation (list elt) list_permut <br/>
reflexivity proved by list_permut_refl<br/>
symmetry proved by list_permut_sym<br/>
transitivity proved by list_permut_trans as LP.<br/>

<br/>
</code>

<div class="doc">
Permutation of an empty list. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="list_permut_nil"></a>list_permut_nil :<br/>
&nbsp;forall l, list_permut l nil -&gt; l = nil.<br/>

<br/>
</code>

<div class="doc">
<a name="lab7"></a><h2>Compatibility Properties.</h2 class="section">

 Permutation is compatible with In. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="in_permut_in"></a>in_permut_in :<br/>
&nbsp;&nbsp;forall l1 l2 e, In e l1 -&gt; list_permut l1 l2 -&gt; In e l2.<br/>

<br/>
Add Morphism (In (A :=elt)) : in_morph.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="cons_permut_in"></a>cons_permut_in :<br/>
&nbsp;&nbsp;forall l1 l2 e, list_permut (e :: l1) l2 -&gt; In e l2.<br/>

<br/>
</code>

<div class="doc">
Permutation is compatible with adding an element. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="context_list_permut_cons"></a>context_list_permut_cons :<br/>
&nbsp;&nbsp;forall e l1 l2, list_permut l1 l2 -&gt; list_permut (e :: l1) (e :: l2).<br/>

<br/>
Add Morphism (List.cons (A:=elt)) : add_elt_morph.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_permut_add_inside"></a>list_permut_add_inside :<br/>
forall a l1 l2 l3 l4, <br/>
&nbsp;&nbsp;list_permut (l1 ++ l2) (l3 ++ l4) -&gt;<br/>
&nbsp;&nbsp;list_permut (l1 ++ a :: l2) (l3 ++ a :: l4).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_permut_add_cons_inside"></a>list_permut_add_cons_inside :<br/>
forall a l l1 l2, <br/>
&nbsp;&nbsp;list_permut l (l1 ++ l2) -&gt;<br/>
&nbsp;&nbsp;list_permut (a :: l) (l1 ++ a :: l2).<br/>

<br/>
</code>

<div class="doc">
Permutation is compatible with append. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="context_list_permut_app1"></a>context_list_permut_app1 :<br/>
&nbsp;&nbsp;forall l l1 l2, list_permut l1 l2 -&gt; list_permut (l ++ l1) (l ++ l2).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="context_list_permut_app2"></a>context_list_permut_app2 :<br/>
&nbsp;&nbsp;forall l l1 l2, list_permut l1 l2 -&gt; list_permut (l1 ++ l) (l2 ++ l).<br/>

<br/>
Add Morphism (List.app (A:=elt)) : app_morph.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_permut_app_app"></a>list_permut_app_app :<br/>
&nbsp;forall l1 l2, list_permut (l1 ++ l2) (l2 ++ l1).<br/>

<br/>
</code>

<div class="doc">
Permutation is compatible with removal of common elements 
</div>
<code>
<span class="keyword">Lemma</span> <a name="remove_context_list_permut_cons"></a>remove_context_list_permut_cons :<br/>
&nbsp;&nbsp;forall e l1 l2, list_permut (e :: l1) (e :: l2) -&gt; list_permut l1 l2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="remove_context_list_permut_app2"></a>remove_context_list_permut_app2 :<br/>
&nbsp;&nbsp;forall l l1 l2, list_permut (l1 ++ l) (l2 ++ l) -&gt; list_permut l1 l2.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_permut_remove_hd"></a>list_permut_remove_hd :<br/>
&nbsp;&nbsp;forall l l1 l2 a,   <br/>
&nbsp;&nbsp;list_permut (a :: l) (l1 ++ a :: l2) -&gt; list_permut l (l1 ++ l2).<br/>

<br/>
</code>

<div class="doc">
Permutation is compatible with length. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="list_permut_length"></a>list_permut_length :<br/>
&nbsp;forall l1 l2, list_permut l1 l2 -&gt; length l1 = length l2.<br/>

<br/>
Add Morphism (length (A:=elt)) : length_morph.<br/>

<br/>
</code>

<div class="doc">
Permutation is compatible with size. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="list_permut_size"></a>list_permut_size :<br/>
&nbsp;&nbsp;forall size l1 l2, list_permut l1 l2 -&gt; list_size size l1 = list_size size l2.<br/>

<br/>
Add Morphism (fun size =&gt; list_size (A:=elt) size) : list_size_morph.<br/>

<br/>
</code>

<div class="doc">
Permutation is compatible with map. 
</div>
<code>
<span class="keyword">Lemma</span> <a name="list_permut_map"></a>list_permut_map :<br/>
&nbsp;&nbsp;forall f l1 l2, list_permut l1 l2 -&gt; list_permut (map f l1) (map f l2).<br/>

<br/>
Add Morphism (fun l =&gt; fun f : elt -&gt; elt =&gt; map f l) : map_morph.<br/>

<br/>
</code>

<div class="doc">
<a name="lab8"></a><h2>Permutation for short lists.</h2 class="section">

</div>
<code>

<br/>
<span class="keyword">Lemma</span> <a name="list_permut_length_1"></a>list_permut_length_1:<br/>
&nbsp;forall a b, list_permut (a :: nil) (b :: nil)  -&gt; a = b.<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_permut_length_2"></a>list_permut_length_2 :<br/>
&nbsp;forall a1 b1 a2 b2, list_permut (a1 :: b1 :: nil) (a2 :: b2 :: nil) -&gt;<br/>
&nbsp;(a1=a2 /\ b1=b2) \/ (a1=b2 /\ a2=b1).<br/>

<br/>
</code>

<div class="doc">
<a name="lab9"></a><h2>Link with AC syntactic decomposition.</h2 class="section">

</div>
<code>
<span class="keyword">Lemma</span> <a name="ac_syntactic_aux"></a>ac_syntactic_aux :<br/>
&nbsp;forall (l1 l2 l3 l4 : list elt),<br/>
&nbsp;list_permut (l1 ++ l2) (l3 ++ l4) -&gt;<br/>
&nbsp;(exists u1, exists u2, exists u3, exists u4, <br/>
&nbsp;list_permut l1 (u1 ++ u2) /\<br/>
&nbsp;list_permut l2 (u3 ++ u4) /\<br/>
&nbsp;list_permut l3 (u1 ++ u3) /\<br/>
&nbsp;list_permut l4 (u2 ++ u4)).<br/>

<br/>

<br/>

<br/>
<span class="keyword">Lemma</span> <a name="ac_syntactic"></a>ac_syntactic :<br/>
&nbsp;forall (l1 l2 l3 l4 : list elt),<br/>
&nbsp;list_permut (l2 ++ l1) (l4 ++ l3) -&gt;<br/>
&nbsp;(exists u1, exists u2, exists u3, exists u4, <br/>
&nbsp;list_permut l1 (u1 ++ u2) /\<br/>
&nbsp;list_permut l2 (u3 ++ u4) /\<br/>
&nbsp;list_permut l3 (u1 ++ u3) /\<br/>
&nbsp;list_permut l4 (u2 ++ u4)).<br/>

<br/>
<span class="keyword">Lemma</span> <a name="list_permut_dec"></a>list_permut_dec : forall l1 l2, {list_permut l1 l2}+{~list_permut l1 l2}.<br/>

<br/>
<span class="keyword">End</span> Make.<br/>

<br/>
</code>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/><font size="-1">This page has been generated by <a href="http://coq.inria.fr">coqdoc</a></font>
</div>

</div>

</body>
</html>